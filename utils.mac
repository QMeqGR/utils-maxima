/* load the other utils */
load("shanks");
load("bypart_ehm");

/* create random matrix with elements between -1 and 1 */
random_matrix(n,r):=block(
	genmatrix(lambda ([i, j], float(r)/2-random (float(r))),n,n)
);


/* This function diagonalizes matrices. I wrote it because eigenvectors(Sn)
fails for some reason with Sn=S*nhat. This function punts to eigenvectors()
when the dimension is >2. */
diagonalize(M,[u]):=block([val,vec,unitvec:0],
    if u#[] then unitvec:1, /* return unit vectors if the 2nd arg is set */
    if length(M) = 1 then return(M),
    if length(M) = 2 then block([i,N,eqlist,varlist,varsol,vtmp1,evec,eval,mag,mateq],
      eval: fullsimp( solve( charpoly(M,l), l) ),
      N: length(eval),
      evec: makelist(0,k,1,N),
      for i:1 thru N do /* loop over the eigenvals */
        ( vtmp1: transpose( matrix(makelist(concat(c,k),k,1,N) ) ),
          mateq: M.vtmp1-rhs(eval[i])*vtmp1,
          eqlist: makelist(mateq[k][1],k,1,N),
          varlist: makelist(concat(c,k),k,1,N),
          varsol: linsolve( subst([c1=1],eqlist[1]), c2),
          evec[i]: matrix([1],[rhs(varsol[1])]),
          if unitvec=1 then ( mag: sqrt( transpose(conjugate(evec[i])).evec[i] ),
            evec[i]: evec[i]/mag )
         ),
        val:[rhs(eval[1]),rhs(eval[2])],
        vec:evec
      ),
    if length(M) > 2 then block([i,j,lv,cnt:1],
      vec:makelist(0,i,1,length(M)),
      if unitvec=1 then [val,vec2]: uniteigenvectors(M) else [val,vec2]:eigenvectors(M),
      lv:last(val),lenlv:length(lv),
      for i: 1 thru lenlv do
        for j: 1 thru lv[i] do
         ( vec2[i][j]: transpose(matrix(vec2[i][j])),
           vec[cnt]:vec2[i][j], cnt:cnt+1 )
    ),
  [val,vec]
)$

/*************************************************/
/*         Numerical                             */
/*************************************************/

/* shorthand for dgeev call */
lapack_eigs(M):=(
	dgeev(M,true,false)
);

/* Sort the eigenvalues and then the columns of the eigenvectors. This function
should be used only with the dgeev() lapack function, not the eigenvectors()
function. */
sort_evecs(eval,evec):=block([seval,sE],
  seval:sort(eval),
  for i: 1 thru length(seval) do
      for j: 1 thru length(eval) do
          ( if i=1 and seval[i]=eval[j] then sE:col(evec,j),
            if i#1 and seval[i]=eval[j] then sE:addcol(sE,col(evec,j)) ),
[seval,sE]);
