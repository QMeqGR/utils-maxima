/* load the other utils */
load("shanks");
load("bypart_ehm");

/* create random matrix with elements between -1 and 1 */
random_matrix(n,r):=block(
	genmatrix(lambda ([i, j], float(r)/2-random (float(r))),n,n)
);

/* shorthand for dgeev call */
lapack_eigs(M):=(
	dgeev(M,true,false)
);

/* This diagonalizes 2x2 matrices. I wrote it because eigenvectors(Sn)
fails for some reason with Sn=S*nhat. This function punts to eigenvectors()
when the dimension is >2. */
diagonalize(M):=block([i,N,eqlist,varlist,varsol,vtmp1,evec,eval,mag],
    if length(M) > 2 then return(eigenvectors(M)),
    if length(M) = 1 then return(M),
    eval: fullsimp( solve( charpoly(M,l), l) ),
    N: length(eval),
    evec: makelist(0,k,1,N),
    for i:1 thru N do /* loop over the eigenvals */
        (   vtmp1: transpose( matrix(makelist(concat(c,k),k,1,N) ) ),
            mateq: M.vtmp1-rhs(eval[i])*vtmp1,
            eqlist: makelist(mateq[k][1],k,1,N),
            varlist: makelist(concat(c,k),k,1,N),
            varsol: linsolve( subst([c1=1],eqlist[1]), c2),
            evec[i]: matrix([1],[rhs(varsol[1])]),
            mag: sqrt( transpose(conjugate(evec[i])).evec[i] ),
            evec[i]: evec[i]/mag
        ),
    out: [[rhs(eval[1]),rhs(eval[2])],evec]
)$

/* Sort the eigenvalues and then the columns of the eigenvectors. This is
only necessary for the builtin eigenvectors() function. My function has
them sorted already. */
sort_evecs(eval,evec):=block(
  seval:sort(eval),
  for i: 1 thru length(seval) do
      for j: 1 thru length(eval) do
          ( if i=1 and seval[i]=eval[j] then sE:col(evec,j),
            if i#1 and seval[i]=eval[j] then sE:addcol(sE,col(evec,j)) ),
[seval,sE]);
